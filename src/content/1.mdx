# 1. `useLazyQuey` fetcher function call inside `useEffect`

> [Apollo Docs - useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery)

Supppose you have component which is rendered in the page that needs to fetch data

- 1. as soon as page loads and
- 2. based on some conditions like change in date range or userId.

Your first instinct might be to use the `fetcher(getData)` function from `useLazyQuey` and trigger the fetch whenever date range or userId changes using `useEffect`.

```js showLineNumbers {5}{8-18} /getData/ /useLazyQuery/
function Page({ userId }) {

  const [dateRange, setDateRange] = useState([startDate, endDate]);

  const [getData, { loading, data }] = useLazyQuery(MY_QUERY);


  useEffect(() => {
    if (!userId || !dateRange.length) return;
    getData({
      variables: {
        startTime: dateRange[0].toISOString(),
        endTime: dateRange[1].toISOString(),
        userId,
      },
    });
  }, [dateRange, userId]);

  // rest of the component
}
```

This approach will work however it is not the intened way this library it is supposed to be used. Instead, you should use `useQuery` which is designed to handle initial data fetching and re-fetching based on variable changes.

```js showLineNumbers {5-11}
function Page({ userId }) {
  const [dateRange, setDateRange] = useState([startDate, endDate]);

  // âœ… Use useQuery for initial data fetching and re-fetching
  const { loading, data } = useQuery(MY_QUERY, {
    skip: !userId || !dateRange.length,
    variables: {
      startTime: dateRange[0].toISOString(),
      endTime: dateRange[1].toISOString(),
      userId,
    },
  });

  // rest of the component
}
```

In the this example, data will be fetched immediately when the component mounts, and it will also re-fetch whenever `dateRange` or `userId` changes since change is `useQuery` variables will trigger a re-fetch automatically.

## Examples

### 1. In Pages

ðŸ›‘ **Avoid**\
In the below example, `useLazyQuery` is utilized to fetch the dashboard items. However, this can be streamlined by using `useQuery` directly, as the data is required immediately upon the component's mount and it doesn't depend on any user interaction.

```js filename="page/dashboard/index.js" showLineNumbers {6-11}{17-25}
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
    {
      fetchPolicy: "no-cache",
    },
  );

  const [dashboardDetails, setDashboardDetails] = useState( defaultDashboardDetails);

  const { homes, setHomes, homesList } = useContext(homesFilterContext);

  useEffect(() => {
    if (homes.length > 0) {
      // Fetch dashboard items
      getDashboardItems({
        variables: { homeIds: homes.map((home) => home.id) },
      });
    }
  }, [homes]);

  // Process data into tasks, signoffs and alerts

  useEffect(() => {
    if (!data) return;
    const { dashboardDetails } = data;
    if (!dashboardDetails) return;
    setDashboardDetails(dashboardDetails);
  }, [data]);

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

âœ… **Good**\
In this example, `useQuery` is used to fetch the dashboard items directly. This is more efficient and cleaner since the data is needed immediately and doesn't required any user interaction to trigger the fetch.

```js filename="page/dashboard/index.js" showLineNumbers {6,10,11, 20}
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const { loading = false, error, data, } = useQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY, 
    {
      fetchPolicy: "no-cache",
      variables: { homeIds: homes.map((home) => home.id) },
      skip: homes.length === 0,
    }
  );

  const [dashboardDetails, setDashboardDetails] = useState(
    defaultDashboardDetails,
  );

  const { homes, setHomes, homesList } = useContext(homesFilterContext);
  // removed useEffect from here since it's logic is handled by useQuery

  useEffect(() => {
    if (!data) return;
    const { dashboardDetails } = data;
    if (!dashboardDetails) return;
    setDashboardDetails(dashboardDetails);
  }, [data]);

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

Diff View

```diff

-    const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
+    const { loading = false, error, data } = useQuery(
        FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
        {
            fetchPolicy: "no-cache",
+            variables: { homeIds: homes.map((home) => home.id) },
+            skip: homes.length === 0,
        },
    );

-   useEffect(() => {
-       if (homes.length > 0) {
-           // Fetch dashboard items
-           getDashboardItems({
-               variables: { homeIds: homes.map((home) => home.id) },
-           });
-       }
-   }, [homes]);
```

## Extra Notes

#### When should we call the `useLazyQuery` fetcher function inside the `useEffect` hook?

**Never**

## Extra Notes

**How many times this anti pattern occurs in the codebase?**\
**Ans:** 161 times out of 213 times `useLazyQuery` is used, which means 161 extra `useEffect` hooks are created just to call the fetcher function instead of using `useQuery` directly.
