# 1. `useLazyQuery` fetcher function call inside `useEffect`

> [Apollo Docs - useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery)

## 📋 Table of Contents
- [Problem Overview](#problem-overview)
- [The Anti-Pattern](#the-anti-pattern)
- [Recommended Solution](#recommended-solution)
- [Examples](#examples)
- [Migration Guide](#migration-guide)
- [Performance Impact](#performance-impact)
- [When to Use Each Pattern](#when-to-use-each-pattern)

## 🚨 Problem Overview

**TL;DR**: Using `useLazyQuery` + `useEffect` for immediate data fetching is an anti-pattern. Use `useQuery` with `skip` and `variables` instead.

**Impact**: This pattern occurs in **161/213** (75.6%) of `useLazyQuery` uses in our codebase, creating unnecessary complexity and performance overhead.

## ⚠️ The Anti-Pattern

Suppose you have a component that needs to fetch data:
1. As soon as the page loads **and**
2. Based on conditions like date range or userId changes

Your first instinct might be to use the `fetcher(getData)` function from `useLazyQuery` and trigger the fetch whenever dependencies change using `useEffect`.

```js showLineNumbers {5}{8-18} /getData/ /useLazyQuery/
function Page({ userId }) {

  const [dateRange, setDateRange] = useState([startDate, endDate]);

  const [getData, { loading, data }] = useLazyQuery(MY_QUERY);


  useEffect(() => {
    if (!userId || !dateRange.length) return;
    getData({
      variables: {
        startTime: dateRange[0].toISOString(),
        endTime: dateRange[1].toISOString(),
        userId,
      },
    });
  }, [dateRange, userId]);

  // rest of the component
}
```

❌ **Why this is problematic:**
- Creates unnecessary `useEffect` hooks
- Manual dependency management
- Potential race conditions
- More boilerplate code
- Harder to test and debug

## ✅ Recommended Solution

Instead, use `useQuery` which is designed to handle initial data fetching and re-fetching based on variable changes automatically.

```js showLineNumbers {5-11}
function Page({ userId }) {
  const [dateRange, setDateRange] = useState([startDate, endDate]);

  // ✅ Use useQuery for initial data fetching and re-fetching
  const { loading, data } = useQuery(MY_QUERY, {
    skip: !userId || !dateRange.length,
    variables: {
      startTime: dateRange[0].toISOString(),
      endTime: dateRange[1].toISOString(),
      userId,
    },
  });

  // rest of the component
}
```

✨ **Benefits of this approach:**
- Automatic re-fetching when variables change
- Built-in conditional fetching with `skip`
- Better integration with Apollo's cache
- Cleaner, more readable code
- Less potential for bugs

In this example, data will be fetched immediately when the component mounts, and it will also re-fetch whenever `dateRange` or `userId` changes since changes in `useQuery` variables trigger a re-fetch automatically.

## 📚 Examples

### 1. Dashboard Page Component

#### 🛑 **Avoid: Using `useLazyQuery` + `useEffect`**

In the below example, `useLazyQuery` is utilized to fetch dashboard items. However, this can be streamlined by using `useQuery` directly, as the data is required immediately upon the component's mount and doesn't depend on any user interaction.

```js filename="page/dashboard/index.js" showLineNumbers {6-11}{17-24}
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
    {
      fetchPolicy: "no-cache",
    },
  );

  const [dashboardDetails, setDashboardDetails] = useState( defaultDashboardDetails);

  const { homes, setHomes, homesList } = useContext(homesFilterContext);

  useEffect(() => {
    if (homes.length > 0) {
      // Fetch dashboard items
      getDashboardItems({
        variables: { homeIds: homes.map((home) => home.id) },
      });
    }
  }, [homes]);

  // Process data into tasks, signoffs and alerts

  useEffect(() => {
    if (!data) return;
    const { dashboardDetails } = data;
    if (!dashboardDetails) return;
    setDashboardDetails(dashboardDetails);
  }, [data]);

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

#### ✅ **Recommended: Using `useQuery` with `skip`**

In this example, `useQuery` is used to fetch the dashboard items directly. This is more efficient and cleaner since the data is needed immediately and doesn't require any user interaction to trigger the fetch.

```js filename="page/dashboard/index.js" showLineNumbers {6,10,11, 20}
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const { loading = false, error, data, } = useQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY, 
    {
      fetchPolicy: "no-cache",
      variables: { homeIds: homes.map((home) => home.id) },
      skip: homes.length === 0,
    }
  );

  const [dashboardDetails, setDashboardDetails] = useState(
    defaultDashboardDetails,
  );

  const { homes, setHomes, homesList } = useContext(homesFilterContext);
  // removed useEffect from here since it's logic is handled by useQuery

  useEffect(() => {
    if (!data) return;
    const { dashboardDetails } = data;
    if (!dashboardDetails) return;
    setDashboardDetails(dashboardDetails);
  }, [data]);

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

#### 🔄 **Migration Diff**

```diff filename="page/dashboard/index.js"
-    const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
+    const { loading = false, error, data } = useQuery(
        FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
        {
            fetchPolicy: "no-cache",
+            variables: { homeIds: homes.map((home) => home.id) },
+            skip: homes.length === 0,
        },
    );

-   useEffect(() => {
-       if (homes.length > 0) {
-           // Fetch dashboard items
-           getDashboardItems({
-               variables: { homeIds: homes.map((home) => home.id) },
-           });
-       }
-   }, [homes]);
```

**Code reduction:** -10 lines, -1 useEffect, -1 function call


### 2. Custom Hook with Mutations

In this example, multiple `useEffect` hooks are used to refetch data after mutations. This can be simplified by using `useMutation` with the `refetchQueries` option.

#### 🛑 **Avoid: Multiple `useEffect` for refetching**

```js showLineNumbers {8-13}{15-17}{19-23}{25-31}
export const useSharpItems = ({ query = FETCH_SHARP_ITEMS, mutation = ADD_UPDATE_SHARP_ITEM }) => {
	const [sharpItems, setSharpItems] = useState([])
	const [filter, setFilter] = useState({})
	const [getSharpItems, { loading, error, data }] = useLazyQuery(query, { fetchPolicy: 'no-cache' })
	const [addUpdateSharpItem, {updateData,...others}] = useMutation(mutation)
	const [deleteSharpItem, {deleteData,...others}] = useMutation(DELETE_SHARP_ITEM)

	useEffect(() => {
		if (data) {
			const { sharpItems: sharpItemsData = [] } = data
			if (sharpItemsData) setSharpItems(sharpItemsData)
		}
	}, [data])

	useEffect(() => {
		getSharpItems({ variables: { ...filter } })
	}, [filter])

	useEffect(() => {
		if (updateData) {
			getSharpItems()
		}
	}, [updateData])

	useEffect(() => {
		if (!deleteData) return
		const { deleteSharpItem } = deleteData
		if (deleteSharpItem) {
			getSharpItems({ variables: { ...filter } })
		}
	}, [deleteData])

	const onUpdateSharpItem = async update => {
		if (!update) return
		var updateObject = { ...update }
		await addUpdateSharpItem({ variables: { sharpItemDetails: updateObject } })
	}

	return {
        //...return items
	}
}

```

#### ✅ **Recommended: Using `useQuery` with `refetchQueries`**

This approach achieves the same functionality with significantly less code and better maintainability.

```js showLineNumbers {8,11,14}
export const useSharpItems = ({ query = FETCH_SHARP_ITEMS, mutation = ADD_UPDATE_SHARP_ITEM }) => {
	const [filter, setFilter] = useState({})
	const { loading, error, data } = useQuery(query, {
		fetchPolicy: 'no-cache',
		variables: { ...filter }// replaces the useEffect at line 15-17
	})

	const sharpItems = data?.sharpItems || [] //removes the usEffect in the above code at line 8-13, state at line 2

	const [addUpdateSharpItem, {updateData,...}] = useMutation(mutation, {
		refetchQueries: [query] //this line replaces the useEffect in the above code 19-23
	})
	const [deleteSharpItem,{deleteData,...}] = useMutation(DELETE_SHARP_ITEM, {
		refetchQueries: [query] // this line replaces the useEffect in the above code 25-31
	})


	const onUpdateSharpItem = async update => {
		if (!update) return
		var updateObject = { ...update }
		await addUpdateSharpItem({ variables: { sharpItemDetails: updateObject } })
	}

	return {
        //...return items
	}
}

```

#### 🔄 **Migration Diff**

```diff filename="useSharpItems.js"
-    const [sharpItems, setSharpItems] = useState([])
-    const [getSharpItems, { loading, error, data }] = useLazyQuery(query, { fetchPolicy: 'no-cache' })
+    const { loading, error, data } = useQuery(query, {
+        fetchPolicy: 'no-cache',
+        variables: { ...filter }
+    })

+    const sharpItems = data?.sharpItems || []

     const [addUpdateSharpItem, {...}] = useMutation(mutation, {
+        refetchQueries: [query]
+    })
     const [deleteSharpItem, {...}] = useMutation(DELETE_SHARP_ITEM, {
+        refetchQueries: [query]
     })

-    useEffect(() => {
-        if (data) {
-            const { sharpItems: sharpItemsData = [] } = data
-            if (sharpItemsData) setSharpItems(sharpItemsData)
-        }
-    }, [data])

-    useEffect(() => {
-        getSharpItems({ variables: { ...filter } })
-    }, [filter])

-    useEffect(() => {
-        if (updateData) {
-            getSharpItems()
-        }
-    }, [updateData])

-    useEffect(() => {
-        if (!deleteData) return
-        const { deleteSharpItem } = deleteData
-        if (deleteSharpItem) {
-            getSharpItems({ variables: { ...filter } })
-        }
-    }, [deleteData])
```

**Code reduction:** -28 lines, -4 useEffect hooks, -1 useState, -1 function



## 🚀 Performance Impact

**Codebase Statistics:**
- **161/213** (75.6%) of `useLazyQuery` uses follow this anti-pattern
- **161 unnecessary `useEffect` hooks** that can be eliminated
- **Average 15-20 lines reduction** per component
- **Better cache utilization** with `useQuery`

## 🤔 When to Use Each Pattern

### ✅ Use `useQuery` when:
- Data is needed immediately on component mount
- Data depends on props/state that change over time
- You need automatic cache management
- You want cleaner, more maintainable code

### ✅ Use `useLazyQuery` when:
- Data fetching is triggered by user interaction (e.g., button click)
- Data is fetched based on specific events that don't occur on initial render
- You need manual control over when the query executes
- The query is optional and may never be executed

## 📝 Migration Checklist

- [ ] Identify `useLazyQuery` + `useEffect` patterns in your code
- [ ] Replace `useLazyQuery` with `useQuery`
- [ ] Move variables from `useEffect` to `useQuery` options
- [ ] Add `skip` condition if needed
- [ ] Remove unnecessary `useEffect` hooks
- [ ] Update `useMutation` to use `refetchQueries` instead of manual refetching
- [ ] Test the component to ensure behavior remains the same
- [ ] Remove unused imports and state variables
