# 2. Duplicate/Redundant State

> [React Docs - Redundant State](https://react.dev/learn/choosing-the-state-structure#avoid-redundant-state)\
> [React Docs - You Might Not need an Effect](https://react.dev/learn/you-might-not-need-an-effect)

## 📋 Table of Contents
- [Problem Overview](#problem-overview)
- [The Anti-Pattern](#the-anti-pattern)
- [Recommended Solution](#recommended-solution)
- [Examples](#examples)
- [Migration Guide](#migration-guide)
- [Performance Impact](#performance-impact)
- [Detection Methods](#detection-methods)

## 🚨 Problem Overview

**TL;DR**: Storing derivable data in state creates unnecessary complexity and re-renders. Calculate values directly from props or existing state during rendering instead.

**Impact**: This pattern occurs **717 times** in our codebase, meaning 717 unnecessary `useState` and `useEffect` combinations that can be simplified to constant variables.

## ⚠️ The Anti-Pattern

If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.

**Common symptoms:**
- `useState` setter only called inside `useEffect`
- State that mirrors props or other state
- Unnecessary re-renders from derived state updates

## ✅ Recommended Solution

Replace redundant state with **derived values** calculated directly during rendering. This eliminates unnecessary `useState` and `useEffect` combinations.

## 📚 Examples

### 1. Dashboard Details State

#### 🛑 **Avoid: Using `useState` + `useEffect` for derived data**

In this example, the `data` returned from `useLazyQuery` is used as a dependency in `useEffect` to update the `dashboardDetails` state, triggering a re-render. However, this is unnecessary since `data` is already reactive, and any state change will automatically re-render the component.

```js filename="page/dashboard/index.js" showLineNumbers {29-34}{13} /data/2,6
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
    {
      fetchPolicy: "no-cache",
    },
  );

  const [dashboardDetails, setDashboardDetails] = useState(defaultDashboardDetails);

  const { homes, setHomes, homesList } = useContext(homesFilterContext);

  // Fetch from apollo
  useEffect(() => {
    if (homes.length > 0) {
      // Fetch dashboard items
      getDashboardItems({
        variables: { homeIds: homes.map((home) => home.id) },
      });
    }
  }, [homes]);

  // Process data into tasks, signoffs and alerts

  useEffect(() => {
    if (!data) return;
    const { dashboardDetails } = data;
    if (!dashboardDetails) return;
    setDashboardDetails(dashboardDetails);
  }, [data]);

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

#### ✅ **Recommended: Direct derivation from props/state**

In this example, a constant variable `dashboardDetails` is derived directly from the data instead of using state. This approach eliminates unnecessary state management and re-renders.

```js filename="page/dashboard/index.js" showLineNumbers {28,16}
function MyDashboard(props) {
  const { data: session } = useSession({ required: true });
  const userType = session?.user?.type;
  const isStaff = userType === "staff";

  const [getDashboardItems, { loading = false, error, data }] = useLazyQuery(
    FETCH_FEW_ALERT_TASK_SIGNOFF_GQL_QUERY,
    {
      fetchPolicy: "no-cache",
    },
  );

  const { homes, setHomes, homesList } = useContext(homesFilterContext);

  // replaced the state with a constant variable, derived directly from data
  const dashboardDetails = data?.dashboardDetails || defaultDashboardDetails;

  // Fetch from apollo
  useEffect(() => {
    if (homes.length > 0) {
      // Fetch dashboard items
      getDashboardItems({
        variables: { homeIds: homes.map((home) => home.id) },
      });
    }
  }, [homes]);

  // removed the useEffect to set dashboardDetails

  const {
    alerts = [],
    urgentAlerts = [],
    alertsUrgentCount = 0,
    alertsOverdueCount = 0,
    tasks = [],
    tasksUpcomingCount = 0,
    tasksOverdueCount = 0,
    signoffs = [],
    signoffsUpcomingCount = 0,
    signoffsOverdueCount = 0,
  } = dashboardDetails;

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

#### 🔄 **Migration Diff**

```diff filename="page/dashboard/index.js"
function MyDashboard(props) {
-  const [dashboardDetails, setDashboardDetails] = useState(defaultDashboardDetails);
+  const dashboardDetails = data?.dashboardDetails || defaultDashboardDetails;

- useEffect(() => {
-   if (!data) return;
-   const { dashboardDetails } = data;
-   if (!dashboardDetails) return;
-   setDashboardDetails(dashboardDetails);
- }, [data]);

  return <LCAccess>{/* rest of the code */}</LCAccess>;
}
```

**Code reduction:** -7 lines, -1 useState, -1 useEffect

### 2. Session-derived State

#### 🛑 **Avoid: Storing derived session values in state**

In this example, `homeType` and `userType` are stored in the component's state, but they can be derived directly from the session data. This creates unnecessary state management and re-renders.

```js showLineNumbers  {7,8}{11-14}
export const CYPSafeguardingEditLayout = ({
  ...props
}) => {

  const { data: session } = useSession();

  const [userType, setUserType] = useState("staff");
  const [homeType, setHomeType] = useState("children_home");
  // ...other states

  useEffect(() => {
    if (session?.user?.currentHome?.type) setHomeType(session.user.currentHome.type);
    if (session?.user?.type) setUserType(session.user.type);
  }, [session]);


  return (
    <Layout page={page} breads={updatedBreads}>
      {/* rest of the code */}
    </Layout>
  );
};
```

#### ✅ **Recommended: Direct derivation from session data**

In this improved version, `homeType` and `userType` are derived directly from the session data, eliminating the need for redundant state variables. This simplifies the component and reduces unnecessary re-renders.

```js showLineNumbers  {7-9}{13}
export const CYPSafeguardingEditLayout = ({
  ...props
}) => {

  const { data: session } = useSession();

  //  replaced the state with constants, derived directly from session
  const userType = session?.user?.type || "staff";
  const homeType = session?.user?.currentHome?.type || "children_home";
  // ...other states


    // removed useEffect from here

  return (
    <Layout page={page} breads={updatedBreads}>
      {/* rest of the code */}
    </Layout>
  );
};
```

#### 🔄 **Migration Diff**

```diff filename="CYPSafeguardingEditLayout.js"
export const CYPSafeguardingEditLayout = ({
	page = null,
	safeguardingId,
	safeguardingDetails = {},
	cypId,
	cypDetails = null,
	fetchingSafeguarding = false,
	breads = [],
	updatingSafeguarding,
	isConfidential,
	isArchived,
	isEditable = true,
	...props
}) => {
	const [updatedBreads, setUpdatedBreads] = useState([])

-	const [userType, setUserType] = useState('staff')
-	const [homeType, setHomeType] = useState('children_home')
+   const userType = session?.user?.type || 'staff';
+   const homeType = session?.user?.currentHome?.type || 'children_home';

	const { data: session } = useSession()

	const authorizedPersonnel = safeguardingDetails?.authorizedPersonnel

-	useEffect(() => {
-		if (session?.user?.currentHome?.type) setHomeType(session.user.currentHome.type)
-		if (session?.user?.type) setUserType(session.user.type)
-	}, [session])

	return (
		<Layout page={page} breads={updatedBreads}>
            {/* rest of the code */}
        </Layout>
	)
}
```

**Code reduction:** -8 lines, -2 useState, -1 useEffect

## 🚀 Performance Impact

**Codebase Statistics:**
- **717 occurrences** of this anti-pattern
- **717 unnecessary** `useState` and `useEffect` combinations
- **Average 6-8 lines reduction** per component
- **Fewer re-renders** due to eliminated state updates
- **Better performance** with direct derivation

## 🕵️ Detection Methods

**How to identify this anti-pattern:**
- `useState` setter function only called inside `useEffect`
- State that directly mirrors props or other state
- State updated immediately after another state/prop changes
- No direct user interaction with the state setter

## 📝 Migration Checklist

- [ ] Identify state variables that are only set in `useEffect`
- [ ] Check if the state can be derived from props or other state
- [ ] Replace `useState` with `const` variable
- [ ] Remove associated `useEffect` hook
- [ ] Verify component behavior remains the same
- [ ] Test for potential performance improvements
- [ ] Update any TypeScript interfaces if needed

## 💡 Best Practices

### ✅ **Do:**
- Derive values directly from props/state during render
- Use `useMemo` for expensive calculations
- Keep state minimal and focused
- Prefer computed values over stored values

### ❌ **Don't:**
- Store values that can be calculated
- Create state just to transform other state
- Use `useEffect` to sync derived state
- Over-complicate simple derivations
